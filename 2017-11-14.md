# 常用正则表达式
### 一、校验数字的表达式
#### 数字：`^[0-9]*$`
#### n位的数字：` ^\d{n}$`
#### 至少n位的数字：`^\d{n,}$`
#### m-n位的数字：`^\d{m,n}$`
#### 零和非零开头的数字：`^(0|[1-9][0-9]*)$`
#### 非零开头的最多带两位小数的数字：`1^([1-9][0-9]*)+(.[0-9]{1,2})?$`
#### 带1-2位小数的正数或负数：`^(\-)?\d+(\.\d{1,2})?$`
#### 正数、负数、和小数：`^(\-|\+)?\d+(\.\d+)?$`
#### 有两位小数的正实数：`^[0-9]+(.[0-9]{2})?$`
#### 有1~3位小数的正实数：`^[0-9]+(.[0-9]{1,3})?$`
#### 非零的正整数：`^[1-9]\d*$` 或 `^([1-9][0-9]*){1,3}$` 或 `^\+?[1-9][0-9]*$`
#### 非零的负整数：`^\-[1-9][]0-9″*$` 或 `^-[1-9]\d*$`
#### 非负整数：`^\d+$` 或 `^[1-9]\d*|0$`
#### 非正整数：`^-[1-9]\d*|0$` 或 `^((-\d+)|(0+))$`
#### 非负浮点数：`^\d+(\.\d+)?$` 或 `^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$`
#### 非正浮点数：`^((-\d+(\.\d+)?)|(0+(\.0+)?))$` 或 `^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$`
#### 正浮点数：`^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$` 或 `^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$`
#### 负浮点数：`^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$` 或 `^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$`
#### 浮点数：`^(-?\d+)(\.\d+)?$` 或 `^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$`
### 二、校验字符的表达式
#### 汉字：`^[\u4e00-\u9fa5]{0,}$`
#### 英文和数字：`^[A-Za-z0-9]+$` 或 `^[A-Za-z0-9]{4,40}$`
#### 长度为3-20的所有字符：`^.{3,20}$`
#### 由26个英文字母组成的字符串：`^[A-Za-z]+$`
#### 由26个大写英文字母组成的字符串：`^[A-Z]+$`
#### 由26个小写英文字母组成的字符串：`^[a-z]+$`
#### 由数字和26个英文字母组成的字符串：`^[A-Za-z0-9]+$`
#### 由数字、26个英文字母或者下划线组成的字符串：`^\w+$ 或 ^\w{3,20}$`
#### 中文、英文、数字包括下划线：`^[\u4E00-\u9FA5A-Za-z0-9_]+$`
#### 中文、英文、数字但不包括下划线等符号：`^[\u4E00-\u9FA5A-Za-z0-9]+$` 或 `^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$`
#### 可以输入含有^%&',;=?$\”等字符：`[^%&',;=?$\x22]+`
#### 禁止输入含有~的字符：`[^~\x22]+`
##### 三、特殊需求表达式
#### Email地址：`^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$`
#### 域名：`[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?`
#### InternetURL：`[a-zA-z]+://[^\s]*` 或 `^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$`
#### 手机号码：`^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$`
#### 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：`^($$\d{3,4}-)|\d{3.4}-)?\d{7,8}$`
#### 国内电话号码(0511-4405222、021-87888822)：`\d{3}-\d{8}|\d{4}-\d{7}`
#### 银行卡号：(6228480402564890018) :`/([\d]{4})([\d]{4})([\d]{4})([\d]{4})([\d]{0,})?/` 或者：  `/^([1-9]{1})(\d{14}|\d{18})$/`
#### 车牌号：`/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/`
#### 身份证号(15位、18位数字)：`^\d{15}|\d{18}$`
#### 短身份证号码(数字、字母x结尾)：`^([0-9]){7,18}(x|X)?$` 或 `^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$`
#### 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：`^[a-zA-Z][a-zA-Z0-9_]{4,15}$`
#### 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：`^[a-zA-Z]\w{5,17}$`
#### 强密码(必须包含大小写字母和数字的组合，不能使用#### 特殊字符，长度在8-10之间)：`^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$`
#### 日期格式：`^\d{4}-\d{1,2}-\d{1,2}`
#### 一年的12个月(01～09和1～12)：`^(0?[1-9]|1[0-2])$`
#### 一个月的31天(01～09和1～31)：`^((0?[1-9])|((1|2)[0-9])|30|31)$`
#### 钱的输入格式：
  - 有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：`^[1-9][0-9]*$`
  - 这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：`#### ^(0|[1-9][0-9]*)$`
  - 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：`^(0|-?[1-9][0-9]*)$`
  - 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：`^[0-9]+(.[0-9]+)?$`
  - 必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：`^[0-9]+(.[0-9]{2})?$`
  - 这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：`^[0-9]+(.[0-9]{1,2})?$`
  - 这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：`^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$`
  - 1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：`^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$`
  - 备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里

#### xml文件：`^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$`
#### 中文字符的正则表达式：`[\u4e00-\u9fa5]`
#### 双字节字符：`[^\x00-\xff]` (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
#### 空白行的正则表达式：`\n\s*\r` (可以用来删除空白行)
#### HTML标记的正则表达式：`<(\S*?)[^>]*>.*?</\1>|<.*? />` (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
#### 首尾空白字符的正则表达式：`^\s*|\s*$或(^\s*)|(\s*$) `(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
#### 腾讯QQ号：`[1-9][0-9]{4,} (腾讯QQ号从10000开始)
#### 中国邮政编码：[1-9]\d{5}(?!\d)` (中国邮政编码为6位数字)
#### IP地址：`\d+\.\d+\.\d+\.\d+` (提取IP地址时有用)
#### IP地址：`((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))`
#### 十六进制颜色正则：`（#b8b8b8）/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/`

### 用正则表达式限制只能输入中文：
`onkeyup="value=value.replace(/[^u4E00-u9FA5]/g,'') "onbeforepaste="clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[^u4E00-u9FA5]/g,''))" `
#### 用正则表达式限制只能输入全角字符：
`onkeyup="value=value.replace(/[^uFF00-uFFFF]/g,'') "onbeforepaste="clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[^uFF00-uFFFF]/g,''))" `
#### 用正则表达式限制只能输入数字：
`onkeyup="value=value.replace(/[^d]/g,'') "onbeforepaste= "clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[^d]/g,''))" `　
#### 用正则表达式限制只能输入数字和英文：
`onkeyup="value=value.replace(/[W]/g,'') "onbeforepaste="clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[^d]/g,'' `
##  14招搞定JavaScript调试
大多数技巧都是针对Chrome检查器(Inspector)和Firefox，尽管有很多人使用其他检查器。
##### debugger
除了console.log之外，debugger;是我最喜欢的快速debug的工具。一旦在代码中加入了这行语句，Chrome在执行的时候会自动在该行停下来。你甚至可以和条件语句配合使用，仅仅在你需要它的时候开启。
`if(thisThing){
   debugger;
}`
##### 将对象以表格的形式展示
有时候，你需要查看一个复杂的对象元素。通常，我们都会使用console.log将其打印出来然后查看。其实，你还可以使用console.table，让对象更加美观地呈现出来。
`var animals = [
    { animal: 'Horse', name: 'Henry', age: 43 },
    { animal: 'Dog', name: 'Fred', age: 13 },
    { animal: 'Cat', name: 'Frodo', age: 18 }
];`
console.table(animals);`
输出样式：



##### 尝试适配各种机型屏幕大小
如果你拥有各种型号的手机那么测试会相对简单，但是现实可不会这样。其实，你可以直接在浏览器你们改变viewport的大小来查看效果。谷歌浏览器提供了非常强大的功能。在谷歌开发者面板，点击toogle device mode按钮，就可以选择不同的设备大小了。

##### 如何快速找到对应的DOM元素
构造一个DOM元素，然后在控制台(Console)下面使用。谷歌浏览器调试器(Chrome Inspector)保留了最后5个DOM元素的历史。最后一个标记为$0,倒数第二个$1, 以此类推。
如果你按照item-4，item-3，item-2，item-1，item-0的顺序点击这些元素，那么你可以在控制台下使用$x来访问它们。

##### 使用console.time()和console.timeEnd()来记录时间
了解代码的执行时间是非常有用的，特别是调试耗时的for循环。你可以通过定义不同的名字来设置多个timer。我们来演示一下如何操作：
`console.time('Timer1');
 
var items = [];
 
for(var i = 0; i < 100000; i++){
   items.push({index: i});
}
 
console.timeEnd('Timer1');`



##### 获取某个函数的Stacktrace
你也许知道不少JavaScript框架，它们可以一键快速生成大量代码。代码里面包含各种view和事件触发器，最终你会想要搞明白某些函数是如何被调用的。
因为JavaScript并不是一个很结构化的语言，所有有时候要搞清楚何时如何发生的还是比较困难的。在这个时候，我们可以使用console.trace来debug JavaScript。
比如，如果你想看到一个Car实例下，funcZ的整个堆栈详情:
`var car;
var func1 = function() {
  func2();
}
var func2 = function() {
  func4();
}
var func3 = function() {
}
var func4 = function() {
  car = new Car();
  car.funcX();
}
var Car = function() {
  this.brand = ‘volvo’;
  this.color = ‘red’;
  this.funcX = function() {
    this.funcY();
  }
  this.funcY = function() {
    this.funcZ();
  }
  this.funcZ = function() {
    console.trace(‘trace car’)
  }
}
func1();
var car; 
var func1 = function() {
  func2();
} 
var func2 = function() {
  func4();
}
var func3 = function() {
} 
var func4 = function() {
  car = new Car();
  car.funcX();
}
var Car = function() {
  this.brand = ‘volvo’;
  this.color = ‘red’;
  this.funcX = function() {
    this.funcY();
  }
  this.funcY = function() {
    this.funcZ();
  }
  this.funcZ = function() {
    console.trace(‘trace car’)
  }
} 
func1();`
使用console.trace，输出结果如下：

我们可以清晰地看到func1调用func2，func2调用func4，func4创建了一个Car的实例，然后调用了car.funcX，等等。
有时候，尽管你认为对自己的代码非常清楚，使用console.trace依然可以帮你快速定位函数。比如，你想要改进代码，那么通过trace可以获取到所有相关的函数，而且每一个都可以点击直接跳转，就像一个快捷菜单一样。
广告： 如果你需要监控线上JavaScript代码的错误的话，欢迎免费使用Fundebug!
##### 将minify的代码还原
有时候，生产环境的代码出现问题，然而source map并没有和压缩的代码绑定在一起，所有无法看到还原的代码。不用担心，谷歌浏览器可以将JavaScript代码还原到一个可读的样式。尽管还是比不上真实的代码，但是可以很好的帮助你去分析问题了。点击{}来结构化代码：



##### 快速定位需要Debug的函数
设想我们想要在函数中设置一个断点，最常见的两种方式是：
  1. 在检查器中找到这一行代码，然后设置断点；
  2. 在代码中添加debugger
无论哪种方法，你都需要在所有的代码文件中首先找到需要debug的那一行。
还有一个不常用的方式是使用控制台(console)，使用debug(funcName)，脚本会在那行函数处暂停。使用这个方法可以很快定位函数，但是对于私有和匿名函数不适用。(注意：debug和console.debug不是同一个事情！)
`var func1 = function() {
  func2();
};
 
var Car = function() {
  this.funcX = function() {
    this.funcY();
  }
 
  this.funcY = function() {
    this.funcZ();
  }
}
 
var car = new Car();`
在控制台输入debug(car.funcY)，脚本会在函数调用car.funcY处进入debug模式。



##### 屏蔽不相关脚本
我们的代码中都会引入不少库函数和框架。大多数都是经过测试，几乎没有什么bug的。但是debugger会一不小心跳进去。因此，我们可以选择将这些脚本屏蔽。可以查看谷歌浏览器屏蔽文件的设置和火狐浏览器屏蔽文件的设置。
##### 个性化console.log信息
在一些很复杂的Debug中，我们需要输出很多行的日志，使用Console.log，console.debug，console.warn，console.info和console.error。你可以使用过滤器来查看特定的消息，但是有时候你会发现这样并不够。我们可以使用更加富有创造力的方法，使用CSS来个性化定义Console.log打印的消息：

`console.todo = function(msg) {
      console.log('% c % s % s % s‘, ‘color: yellow; background - color: black;' , '–', msg, '–');
    }

    console.important = function(msg) {
      console.log('% c % s % s % s', 'color: brown; font - weight: bold; text - decoration: underline;' , '–', msg, '–');
    }

    `console.todo('This is something that’ s need to be fixed');
    console.important('This is an important message');`
输出的结果如下：



你可以用%s来输出字符串，%i来输出数字，%c来自定义格式。如果你使用单页面框架，对于视图(view)的console消息使用一种格式，模型(model)、集合，控制器各自使用不同的格式。甚至，你可能想要更短的名字，类似于wlog, clog和mlog。
##### 查看某个函数调用和其参数值
在谷歌浏览器控制台，你可以一直观察某个函数。每次它被调用，都会打印传入的参数值。
var func1 = function(x, y, z) {
//....
};



使用monitor函数可以获取到函数运行时传入的参数值。但是，有一个不足在于并没有指明该函数的形参个数。所以func1实际上是需要三个参数的，但是只传入了两个。如果忽略了这种情况，那么可能会导致bug出现。
##### 在控制台快速访问元素
在控制台使用查询选择器(querySelector)很方便, 使用$('css-selector')就可以返回第一个匹配的元素，$$('css-selector')会返回所有匹配的元素。如果你会多次使用某个元素，甚至可以将其保存到变量中。



##### Postman很好(但是Firefox更快)
很多开发者使用Postman来发送Ajax请求。Postman非常好用，但是打开一个新的窗口，并且配置请求对象还是有点繁琐。
如果你不需要担心使用cookie认证，那么你可以在Firefox中编辑和重发请求。
打开检查器，跳转到网络(network)标签。右键点击选中的请求，选择编辑和重发选项。
下图是我将同一个GET请求的属性编辑后再次发送出去的情况：



##### 监控节点元素变化并中断
有时候DOM莫名其妙变化了，然而你并不知道为啥。好在谷歌浏览器提供了一个功能可以在DOM元素变化的时候暂停执行。在谷歌检查器下，右键选中的元素，然后选定要监控的变化类型：Subtree Modifications, Attributes Modifications, Node Removal。

## ES6 扩展运算符 三个点（...）
#### 它是什么
es6中引入扩展运算符（...），它用于把一个数组转化为用逗号分隔的参数序列，它常用在不定参数个数时的函数调用，数组合并等情形。因为typeScript是es6的超集，所以typeScript也支持扩展运算符。


#### 用在哪儿


##### 可变参数个数的函数调用

`function push(array, ...items) {  
  array.push(...items);  
} 

function add(...vals){
  let sum=0;
  for(let i=0;i<vals.length;i++){
    sum+=vals[i];
  }
  return sum;
}

let arr = [1,2,3,4,5,6];
let sum = add(...arr);
console.log(sum);  //21`

##### 更便捷的数组合并


`let arr1 = [1,2];
let arr2 = [5,6];
let newArr = [20];`
//es5 旧写法
`newArr = newArr.concat(arr1).concat(arr2); //[20,1,2,5,6]
console.log(newArr);`
//es6 使用扩展运算符
`newArr = [20,...arr1,...arr2];  //[20,1,2,5,6]
console.log(newArr);`


##### 替代es5的apply方法


// ES5 的写法  
`function f(x, y, z) {  
// ...  
}  `
`var args = [0, 1, 2];  
f.apply(null, args);  `
// ES6 的写法  
`function f(x, y, z) {  
// ...  
}  
var args = [0, 1, 2];  
f(...args);`


###### 求最大值Math.max()


// ES5 的写法  
`Math.max.apply(null, [14, 3, 77])  `
// ES6 的写法  
`Math.max(...[14, 3, 77])`  
//  等同于  
`Math.max(14, 3, 77);`


###### 通过push函数，将一个数组添加到另一个数组的尾部


// ES5 的写法  
`var arr1 = [0, 1, 2];  
var arr2 = [3, 4, 5];  
Array.prototype.push.apply(arr1, arr2);`  
// ES6 的写法  
`let arr1 = [0, 1, 2];  
let arr2 = [3, 4, 5];  
arr1.push(...arr2);  //arr1为1,2,3,4,5`


##### 新建Date类型


// ES5  
`new (Date.bind.apply(Date, [null, 2015, 1, 1])) ` 
// ES6  
`new Date(...[2015, 1, 1]);`


##### 与解构赋值结合，生成新数组


// ES5  
`a = list[0], rest = list.slice(1)` 
// ES6  
`[a, ...rest] = list` 
下面是另外一些例子。  
`const [first, ...rest] = [1, 2, 3, 4, 5];  
first // 1  
rest // [2, 3, 4, 5]  
const [first, ...rest] = [];  
first // undefined  
rest // []:  
const [first, ...rest] = ["foo"];  
first // "foo"  
rest // []`


##### 将字符串转为真正的数组


`[...'hello'] ` 
// `[ "h", "e", "l", "l", "o" ]`
